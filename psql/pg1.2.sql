
-- serial -> bigserial|smallserial

-- it's an alias of integer, 
-- or let's a convenience pseudo-type used to create auto-incrementing integer columns, most commonly for primary keys.

-- serial is shorthand that pg expands into three things
-- 1. integer column
-- 2. sequence
-- 3. default value that pulls from that sequence

drop table if exists users;

create table users (
   id serial, -- or bigserial (biginteger)
   name varchar
);

-- all the following steps are automatically applied using serial  
create sequence users_id_seq as integer;
create table users (
   id integer not null default nextval('users_id_seq'),
   name varchar
);
alter sequence users_id_seq owned by users.id;

insert into users (name) values ('alaedin'); -- pg does -> id = nextval('user_id_seq')

drop table if exists orders;

create table orders (
   id bigint generated always as identity primary key,
   order_number serial,
   customer_name varchar(100),
   order_date date,
   total_amount numeric(10, 2)
);

insert into orders 
   (customer_name, order_date, total_amount)
values
   ('John Doe', '2012-02-13', 122.99),
   ('Jane Smith', '2012-02-13', 299.99),
   ('Bob Johnson', '2012-02-13', 22.99);


select * from orders;

insert into orders (customer_name, order_date, total_amount) 
values ('Alice Brown', '2013-09-12', 88.99)
returning id, order_number;

-- importants

-- 1. gaps are normal 1, 2, 4, 5, ... | don't assume ids are continous
-- 2. deleting rows doesn not reset the sequence
-- 3. manually inserting IDs can break things -> sequecen still thinks the last values was smaller, next insert may fail

-- sequences

-- sequence is database object that generates unique numeric values [IDs, primary keys].
-- let's consider it as a counter stored in the database, independentn of any table.

-- produces a series of integers / ...
-- is transaction-safe but not transactional ? 
-- can be shared across tables
-- often used for auto incrementing columns (serial. identity both use sequences)

create sequence s; -- bigint default data type

create sequence seq
   as integer; -- type: integer start: 1 min_value: 1 max_value: big.int_value increment: 1  

select nextval('seq');
select currval('seq');
select setval('seq', 111000111); 

create sequence seq_w
   as int2 -- smallint
   increment 3 -- increment by
   start 1 -- start with
   minvalue 1
   maxvalue 123;
   -- cahce -> pre-allocate value for performance
   -- cycle -> restart after reaching max | default is set to [no cycle]

select nextval('seq_w');

select currval('seq_w'); -- NOTE: You'll get the current value from the current session (or transaction), which is different from values in other open sessions.


-- sequences are not rolled back -> value is lost, not reused

begin;
select nextval('seq');
rollback;

-- transaction-safe but not transactional

-- transaction-safe -> multiple transactions call nexval() at the same time, pg guarantees:
-- 1. each call gets a uniye value
-- 2. no 2 sessions ever recieve the same number
-- 3. no locking or conflicts needed

-- not transactional -> sequence increments are not part of the transaction
-- 1. the row is rolled back
-- 2. the sequence value is not rolled back

-- identity

-- identity column is the SQL-standard way to create auto-incrementing IDs in pg
-- it's built on top of sequence
-- 

drop table if exists orders;

create table orders (
   id bigint generated always as identity primary key,
   product_name varchar
);


insert into orders (product_name) values ('A21');

select * from orders;

-- always vs default

-- always
-- 1. pg always generates the value, you cannot insert your own ID
-- 2. safest for primary keys 

-- default -> id int generated by default as identity
-- 1. pg generates values unless you override
-- 2. can supply your own ID
-- 3. useful for data migration  

insert into orders (id, product_name) 
values (12, 'A21'); -- column id created using always -> error when insert value

select pg_get_serial_sequence('orders', 'id'); -- getting sequence used for specific column
